\documentclass[11pt,a4paper]{article}

% ---------- Preamble ----------
\input{Preamble/preamble.tex}

% ---------- Title ----------
\title{Programming in Ada -- Notes}
\author{Daniel Duggan}
\date{\today}

% ---------- Document ----------
\begin{document}

\maketitle
\tableofcontents
\newpage

% --------------------------------------------
\section{Chapter 2 Notes: Program Structure in Ada}

Ada programs are composed of several key building blocks: \textbf{packages}, \textbf{procedures}, and \textbf{functions}. Understanding how these components interact is essential to mastering Ada's modular and strongly typed design.

% --------------------------------------------
\subsection{Core Program Units}

In Ada, all logical units of a program are defined within packages or subprograms. A package acts as a container for related declarations and definitions, while procedures and functions are subprograms that perform specific operations.

\textbf{Packages} serve as the primary means of modularization and encapsulation in Ada. Each package typically consists of two parts:
\begin{itemize}
    \item \textbf{Specification (.ads)} — Defines the interface: what the package offers to the outside world.
    \item \textbf{Body (.adb)} — Provides the implementation of the declared entities.
\end{itemize}

A package can contain subprograms (procedures and functions), constants, types, variables, and even other nested packages. This separation of interface and implementation allows for strong information hiding and code organization.

\textbf{Example:}
\begin{lstlisting}[language=Ada]
-- Package specification (like a header)
package Math_Operations is
    function Add (A, B : Integer) return Integer;
    procedure Display_Result (Value : Integer);
end Math_Operations;

-- Package body (like a source file)
package body Math_Operations is
    function Add (A, B : Integer) return Integer is
    begin
        return A + B;
    end Add;

    procedure Display_Result (Value : Integer) is
    begin
        Put_Line("Result: " & Integer'Image(Value));
    end Display_Result;
end Math_Operations;
\end{lstlisting}

This structure mirrors the concept of header/source file separation in languages like C, but with stronger type checking and compiler enforcement.

% --------------------------------------------
\subsection{Subprograms: Procedures and Functions}

Within packages, Ada defines two kinds of subprograms: \textbf{procedures} and \textbf{functions}. Both encapsulate reusable logic, but their intended use differs.

\textbf{Procedures} execute actions and may modify data through parameters or perform I/O, but they do not return a value. They are invoked as standalone statements.

\textbf{Functions}, on the other hand, compute and return a result. They are typically used within expressions and are expected to be free of side effects whenever possible.

\textbf{Example of a Procedure:}
\begin{lstlisting}[language=Ada]
procedure Swap (A, B : in out Integer) is
    Temp : Integer;
begin
    Temp := A;
    A := B;
    B := Temp;
end Swap;

-- Called as a standalone statement
Swap(X, Y);
\end{lstlisting}

\textbf{Example of a Function:}
\begin{lstlisting}[language=Ada]
function Maximum (A, B : Integer) return Integer is
begin
    if A > B then
        return A;
    else
        return B;
    end if;
end Maximum;

-- Used within an expression
Largest := Maximum(X, Y) + 10;
\end{lstlisting}

% --------------------------------------------
\subsection{Comparing the Constructs}

\begin{table}[h]
\centering
\renewcommand{\arraystretch}{1.3} % increases row height for readability
\setlength{\tabcolsep}{8pt} % adds column spacing
\begin{tabular}{|p{3cm}|p{3.2cm}|p{3.2cm}|p{3.2cm}|}
\hline
\rowcolor[HTML]{EFEFEF}
\textbf{Feature} & \textbf{Package} & \textbf{Procedure} & \textbf{Function} \\ 
\hline
\textbf{Purpose} & Groups and organizes related elements & Performs an action or operation & Computes and returns a result \\ 
\hline
\textbf{Return Value} & None & None & Required \\ %
\hline
\textbf{Call Syntax} & Not directly called & Standalone statement & Used within expressions \\ 
\hline
\textbf{Parameters} & N/A & \texttt{in}, \texttt{out}, \texttt{in out} & Typically \texttt{in} only \\ 
\hline
\textbf{Side Effects} & Possible (via internal state) & Common/Expected & Should be avoided (pure computation) \\ 
\hline
\textbf{Scope / Role} & Acts as a container for subprograms & Defines a reusable action & Defines a reusable computation \\ 
\hline
\end{tabular}
\caption{Comparison of Packages, Procedures, and Functions in Ada}
\label{tab:ada_structures}
\end{table}


% --------------------------------------------
\subsection{Additional Notes}

\begin{itemize}
    \item A package acts like a module that groups related functions and procedures together. Its \texttt{.ads} file (specification) declares what is visible externally, while the \texttt{.adb} file (body) contains the implementation.
    \item Procedures and functions can exist within packages or as standalone subprograms in smaller programs.
    \item Ada enforces that each source file name matches its main unit name (e.g., \texttt{print\_roots.adb} must contain \texttt{procedure Print\_Roots}).
    \item Functions are ideal for returning computed results, while procedures are used for actions that affect program state or output.
    \item In Ada, the \texttt{.ads} file plays the role of a C header, and the \texttt{.adb} file corresponds to the C source file—but Ada strictly enforces the relationship between the two.
\end{itemize}

% --------------------------------------------
\subsection{File Organization and Compilation in Practice}

When developing Ada projects, the organization of files is crucial because the GNAT compiler determines dependencies based on file names and locations.

By default, GNAT searches only the \textbf{current directory} for package specifications and bodies. This means that if your main program (\texttt{print\_roots.adb}) is located in:
\begin{verbatim}
Chapter_2_Exercises/
\end{verbatim}
and your package files are stored in a subdirectory like:
\begin{verbatim}
Chapter_2_Exercises/Package_Simple_Maths/Simple_Maths.ads
Chapter_2_Exercises/Package_Simple_Maths/Simple_Maths.adb
\end{verbatim}
GNAT will not find them automatically.

\textbf{Two solutions are common:}
\begin{enumerate}
    \item \textbf{Keep all Ada source files in one directory.}  
    For small projects or exercises, place all \texttt{.adb} and \texttt{.ads} files together:
    \begin{verbatim}
    Chapter_2_Exercises/
    |-- print_roots.adb
    |-- simple_maths.ads
    |-- simple_maths.adb
    |-- simple_io.ads
    `-- simple_io.adb
    \end{verbatim}
    Then compile with:
    \begin{verbatim}
    gnatmake print_roots.adb
    \end{verbatim}
    GNAT will automatically compile all required units.

    \item \textbf{Use a GNAT Project File (.gpr).}  
    For larger or more structured projects, you can specify source directories explicitly:
    \begin{lstlisting}[language=Ada]
    project Chapter_2_Exercises is
       for Source_Dirs use ("./", "Package_Simple_Maths");
       for Main use ("print_roots.adb");
    end Chapter_2_Exercises;
    \end{lstlisting}
    This allows you to maintain a clean folder structure while ensuring GNAT knows where to locate each package. Build with:
    \begin{verbatim}
    gnatmake -P chapter_2_exercises.gpr
    \end{verbatim}
\end{enumerate}

\textbf{Summary:}  
For beginner and educational projects, keeping all files in the same folder is the simplest approach. For larger applications, a project file provides flexibility and better modular organization.



\end{document}
